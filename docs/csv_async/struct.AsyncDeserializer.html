<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Configured CSV `serde` deserializer."><title>AsyncDeserializer in csv_async - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="csv_async" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (c6db1ca3c 2024-08-25)" data-channel="nightly" data-search-js="search-acd2e111c9cb27e3.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-cb0df477c2d67d00.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../csv_async/index.html">csv_<wbr>async</a><span class="version">1.3.0</span></h2></div><h2 class="location"><a href="#">Async<wbr>Deserializer</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.byte_headers">byte_headers</a></li><li><a href="#method.deserialize">deserialize</a></li><li><a href="#method.deserialize_with_pos">deserialize_with_pos</a></li><li><a href="#method.from_reader">from_reader</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_ref">get_ref</a></li><li><a href="#method.has_headers">has_headers</a></li><li><a href="#method.headers">headers</a></li><li><a href="#method.into_deserialize">into_deserialize</a></li><li><a href="#method.into_deserialize_with_pos">into_deserialize_with_pos</a></li><li><a href="#method.into_inner">into_inner</a></li><li><a href="#method.is_done">is_done</a></li><li><a href="#method.position">position</a></li><li><a href="#method.read_byte_record">read_byte_record</a></li><li><a href="#method.read_record">read_record</a></li><li><a href="#method.seek">seek</a></li><li><a href="#method.seek_raw">seek_raw</a></li><li><a href="#method.set_byte_headers">set_byte_headers</a></li><li><a href="#method.set_headers">set_headers</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-AsyncDeserializer%3CR%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-AsyncDeserializer%3CR%3E">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-AsyncDeserializer%3CR%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-AsyncDeserializer%3CR%3E">Send</a></li><li><a href="#impl-Sync-for-AsyncDeserializer%3CR%3E">Sync</a></li><li><a href="#impl-Unpin-for-AsyncDeserializer%3CR%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-AsyncDeserializer%3CR%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&#60;U&#62;</a></li></ul></section><h2><a href="index.html">In crate csv_<wbr>async</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">csv_async</a>::<wbr><a class="struct" href="#">AsyncDeserializer</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/csv_async/async_readers/ades_futures.rs.html#140">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct AsyncDeserializer&lt;R&gt;(<span class="comment">/* private fields */</span>);</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Configured CSV <code>serde</code> deserializer.</p>
<p>A CSV deserializer takes as input CSV data and transforms that into standard Rust
values. The reader reads CSV data is as a sequence of records,
where a record is either a sequence of string fields or structure with derived
<code>serde::Deserialize</code> interface.</p>
<h2 id="configuration"><a class="doc-anchor" href="#configuration">§</a>Configuration</h2>
<p>A CSV deserializer has convenient constructor method <code>from_reader</code>.
However, if you want to configure the CSV deserializer to use
a different delimiter or quote character (among many other things), then
you should use a <a href="struct.AsyncReaderBuilder.html"><code>AsyncReaderBuilder</code></a> to construct
a <code>AsyncDeserializer</code>. For example, to change the field delimiter:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::AsyncReaderBuilder;
 
<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    city: String,
    country: String,
    pop: u64,
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="macro">indoc::indoc!</span> {<span class="string">"
        city;country;pop
        Boston;United States;4628910
    "</span>};
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReaderBuilder::new()
        .delimiter(<span class="string">b';'</span>)
        .create_deserializer(data.as_bytes());

    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.deserialize::&lt;Row&gt;();
    <span class="macro">assert_eq!</span>(records.next().<span class="kw">await</span>.unwrap()<span class="question-mark">?</span>,
               Row {city: <span class="string">"Boston"</span>.to_string(),
                    country: <span class="string">"United States"</span>.to_string(),
                    pop: <span class="number">4628910 </span>});
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h2 id="error-handling"><a class="doc-anchor" href="#error-handling">§</a>Error handling</h2>
<p>In general, CSV <em>parsing</em> does not ever return an error. That is, there is
no such thing as malformed CSV data. Instead, this reader will prioritize
finding a parse over rejecting CSV data that it does not understand. This
choice was inspired by other popular CSV parsers, but also because it is
pragmatic. CSV data varies wildly, so even if the CSV data is malformed,
it might still be possible to work with the data. In the land of CSV, there
is no “right” or “wrong,” only “right” and “less right.”</p>
<p>With that said, a number of errors can occur while reading CSV data:</p>
<ul>
<li>By default, all records in CSV data must have the same number of fields.
If a record is found with a different number of fields than a prior
record, then an error is returned. This behavior can be disabled by
enabling flexible parsing via the <code>flexible</code> method on
<a href="struct.AsyncReaderBuilder.html"><code>AsyncReaderBuilder</code></a>.</li>
<li>When reading CSV data from a resource (like a file), it is possible for
reading from the underlying resource to fail. This will return an error.
For subsequent calls to the reader after encountering a such error
(unless <code>seek</code> is used), it will behave as if end of file had been
reached, in order to avoid running into infinite loops when still
attempting to read the next record when one has errored.</li>
<li>When reading CSV data into <code>String</code> or <code>&amp;str</code> fields (e.g., via a
<a href="struct.StringRecord.html"><code>StringRecord</code></a>), UTF-8 is strictly
enforced. If CSV data is invalid UTF-8, then an error is returned. If
you want to read invalid UTF-8, then you should use the byte oriented
APIs such as <a href="struct.ByteRecord.html"><code>ByteRecord</code></a>. If you need explicit
support for another encoding entirely, then you’ll need to use another
crate to transcode your CSV data to UTF-8 before parsing it.</li>
<li>When using Serde to deserialize CSV data into Rust types, it is possible
for a number of additional errors to occur. For example, deserializing
a field <code>xyz</code> into an <code>i32</code> field will result in an error.</li>
</ul>
<p>For more details on the precise semantics of errors, see the
<a href="enum.Error.html"><code>Error</code></a> type.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsyncDeserializer%3CR%3E" class="impl"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#142-962">source</a><a href="#impl-AsyncDeserializer%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'r, R&gt; <a class="struct" href="struct.AsyncDeserializer.html" title="struct csv_async::AsyncDeserializer">AsyncDeserializer</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="../futures_io/if_std/trait.AsyncRead.html" title="trait futures_io::if_std::AsyncRead">AsyncRead</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'r,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_reader" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#188-190">source</a><h4 class="code-header">pub fn <a href="#method.from_reader" class="fn">from_reader</a>(rdr: R) -&gt; <a class="struct" href="struct.AsyncDeserializer.html" title="struct csv_async::AsyncDeserializer">AsyncDeserializer</a>&lt;R&gt;</h4></section></summary><div class="docblock"><p>Create a new CSV parser with a default configuration for the given
reader.</p>
<p>To customize CSV parsing, use a <code>ReaderBuilder</code>.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::AsyncDeserializer;
 
<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    city: String,
    country: String,
    pop: u64,
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,pop
Boston,United States,4628910
Concord,United States,42695
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.into_deserialize::&lt;Row&gt;();
    <span class="kw">while let </span><span class="prelude-val">Some</span>(record) = records.next().<span class="kw">await </span>{
        <span class="macro">println!</span>(<span class="string">"{:?}"</span>, record<span class="question-mark">?</span>);
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.deserialize" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#383-388">source</a><h4 class="code-header">pub fn <a href="#method.deserialize" class="fn">deserialize</a>&lt;D&gt;(&amp;'r mut self) -&gt; <a class="struct" href="struct.DeserializeRecordsStream.html" title="struct csv_async::DeserializeRecordsStream">DeserializeRecordsStream</a>&lt;'r, R, D&gt;<div class="where">where
    D: <a class="trait" href="../serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a> + 'r,</div></h4></section></summary><div class="docblock"><p>Returns a borrowed stream over deserialized records.</p>
<p>Each item yielded by this stream is a <code>Result&lt;D, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>?</code>).</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record. Additionally,
if <code>has_headers</code> is enabled, then deserializing into a struct will
automatically align the values in each row to the fields of a struct
based on the header row.</p>
<p>Frequently turbo-fish notation is needed while calling this function:
<code>rdr.deserialize::&lt;RecordTyme&gt;();</code></p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>This shows how to deserialize CSV data into normal Rust structures. The
fields of the header row are used to match up the values in each row
to the fields of the struct.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;

<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::AsyncDeserializer;

<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    city: String,
    country: String,
    <span class="attr">#[serde(rename = <span class="string">"popcount"</span>)]
    </span>population: u64,
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,popcount
Boston,United States,4628910
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>iter = rdr.deserialize();

    <span class="kw">if let </span><span class="prelude-val">Some</span>(result) = iter.next().<span class="kw">await </span>{
        <span class="kw">let </span>record: Row = result<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(record, Row {
            city: <span class="string">"Boston"</span>.to_string(),
            country: <span class="string">"United States"</span>.to_string(),
            population: <span class="number">4628910</span>,
        });
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(From::from(<span class="string">"expected at least one record but got none"</span>))
    }
}</code></pre></div>
<h5 id="rules"><a class="doc-anchor" href="#rules">§</a>Rules</h5>
<p>For the most part, any Rust type that maps straight-forwardly to a CSV
record is supported. This includes maps, structs, tuples and tuple
structs. Other Rust types, such as <code>Vec</code>s, arrays, and enums have
a more complicated story. In general, when working with CSV data, one
should avoid <em>nested sequences</em> as much as possible.</p>
<p>Maps, structs, tuples and tuple structs map to CSV records in a simple
way. Tuples and tuple structs decode their fields in the order that
they are defined. Structs will do the same only if <code>has_headers</code> has
been disabled using <a href="struct.ReaderBuilder.html"><code>ReaderBuilder</code></a>,
otherwise, structs and maps are deserialized based on the fields
defined in the header row. (If there is no header row, then
deserializing into a map will result in an error.)</p>
<p>Nested sequences are supported in a limited capacity. Namely, they
are flattened. As a result, it’s often useful to use a <code>Vec</code> to capture
a “tail” of fields in a record:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;

<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::AsyncReaderBuilder;

<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    label: String,
    values: Vec&lt;i32&gt;,
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"foo,1,2,3"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReaderBuilder::new()
        .has_headers(<span class="bool-val">false</span>)
        .create_deserializer(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>iter = rdr.deserialize();

    <span class="kw">if let </span><span class="prelude-val">Some</span>(result) = iter.next().<span class="kw">await </span>{
        <span class="kw">let </span>record: Row = result<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(record, Row {
            label: <span class="string">"foo"</span>.to_string(),
            values: <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],
        });
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(From::from(<span class="string">"expected at least one record but got none"</span>))
    }
}</code></pre></div>
<p>In the above example, adding another field to the <code>Row</code> struct after
the <code>values</code> field will result in a deserialization error. This is
because the deserializer doesn’t know when to stop reading fields
into the <code>values</code> vector, so it will consume the rest of the fields in
the record leaving none left over for the additional field.</p>
<p>Finally, simple enums in Rust can be deserialized as well. Namely,
enums must either be variants with no arguments or variants with a
single argument. Variants with no arguments are deserialized based on
which variant name the field matches. Variants with a single argument
are deserialized based on which variant can store the data. The latter
is only supported when using “untagged” enum deserialization. The
following example shows both forms in action:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;

<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::AsyncDeserializer;

<span class="attr">#[derive(Debug, Deserialize, PartialEq)]
</span><span class="kw">struct </span>Row {
    label: Label,
    value: Number,
}

<span class="attr">#[derive(Debug, Deserialize, PartialEq)]
#[serde(rename_all = <span class="string">"lowercase"</span>)]
</span><span class="kw">enum </span>Label {
    Celsius,
    Fahrenheit,
}

<span class="attr">#[derive(Debug, Deserialize, PartialEq)]
#[serde(untagged)]
</span><span class="kw">enum </span>Number {
    Integer(i64),
    Float(f64),
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
label,value
celsius,22.2222
fahrenheit,72
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>iter = rdr.deserialize();

    <span class="comment">// Read the first record.
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(result) = iter.next().<span class="kw">await </span>{
        <span class="kw">let </span>record: Row = result<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(record, Row {
            label: Label::Celsius,
            value: Number::Float(<span class="number">22.2222</span>),
        });
    } <span class="kw">else </span>{
        <span class="kw">return </span><span class="prelude-val">Err</span>(From::from(
            <span class="string">"expected at least two records but got none"</span>));
    }

    <span class="comment">// Read the second record.
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(result) = iter.next().<span class="kw">await </span>{
        <span class="kw">let </span>record: Row = result<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(record, Row {
            label: Label::Fahrenheit,
            value: Number::Integer(<span class="number">72</span>),
        });
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(From::from(
            <span class="string">"expected at least two records but got only one"</span>))
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.deserialize_with_pos" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#461-466">source</a><h4 class="code-header">pub fn <a href="#method.deserialize_with_pos" class="fn">deserialize_with_pos</a>&lt;D&gt;(
    &amp;'r mut self,
) -&gt; <a class="struct" href="struct.DeserializeRecordsStreamPos.html" title="struct csv_async::DeserializeRecordsStreamPos">DeserializeRecordsStreamPos</a>&lt;'r, R, D&gt;<div class="where">where
    D: <a class="trait" href="../serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a> + 'r,</div></h4></section></summary><div class="docblock"><p>Returns a borrowed stream over pairs of deserialized record and position
in reader stream before record read.</p>
<p>Each item yielded by this stream is a <code>(Result&lt;D, Error&gt;, Position)</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>?</code>).</p>
<p>Frequently turbo-fish notation is needed while calling this function:
<code>rdr.deserialize_with_pos::&lt;RecordTyme&gt;();</code></p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<p>This shows how to deserialize CSV data into normal Rust structures. The
fields of the header row are used to match up the values in each row
to the fields of the struct.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;

<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::AsyncDeserializer;

<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    city: String,
    country: String,
    population: u64,
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,population
Boston,United States,4628910
Concord,United States,42695
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>iter = rdr.deserialize_with_pos();

    <span class="kw">if let </span><span class="prelude-val">Some</span>((result, pos)) = iter.next().<span class="kw">await </span>{
        <span class="kw">let </span>record: Row = result<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(record, Row {
            city: <span class="string">"Boston"</span>.to_string(),
            country: <span class="string">"United States"</span>.to_string(),
            population: <span class="number">4628910</span>,
        });
        <span class="macro">assert_eq!</span>(pos.byte(), <span class="number">24</span>);
        <span class="macro">assert_eq!</span>(pos.line(), <span class="number">2</span>);
        <span class="macro">assert_eq!</span>(pos.record(), <span class="number">1</span>);
    } <span class="kw">else </span>{
        <span class="kw">return </span><span class="prelude-val">Err</span>(From::from(<span class="string">"expected at least one record but got none"</span>));
    }
    <span class="kw">if let </span><span class="prelude-val">Some</span>((result, pos)) = iter.next().<span class="kw">await </span>{
        <span class="kw">let </span>record: Row = result<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(record, Row {
            city: <span class="string">"Concord"</span>.to_string(),
            country: <span class="string">"United States"</span>.to_string(),
            population: <span class="number">42695</span>,
        });
        <span class="macro">assert_eq!</span>(pos.byte(), <span class="number">53</span>);
        <span class="macro">assert_eq!</span>(pos.line(), <span class="number">3</span>);
        <span class="macro">assert_eq!</span>(pos.record(), <span class="number">2</span>);
    } <span class="kw">else </span>{
        <span class="kw">return </span><span class="prelude-val">Err</span>(From::from(<span class="string">"expected at least two records but got one only"</span>));
    }
    <span class="macro">assert!</span>(iter.next().<span class="kw">await</span>.is_none());
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_deserialize" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#527-532">source</a><h4 class="code-header">pub fn <a href="#method.into_deserialize" class="fn">into_deserialize</a>&lt;D&gt;(self) -&gt; <a class="struct" href="struct.DeserializeRecordsIntoStream.html" title="struct csv_async::DeserializeRecordsIntoStream">DeserializeRecordsIntoStream</a>&lt;'r, R, D&gt;<div class="where">where
    D: <a class="trait" href="../serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a> + 'r,</div></h4></section></summary><div class="docblock"><p>Returns a owned stream over deserialized records.</p>
<p>Each item yielded by this stream is a <code>Result&lt;D, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>?</code>).</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record. Additionally,
if <code>has_headers</code> is enabled, then deserializing into a struct will
automatically align the values in each row to the fields of a struct
based on the header row.</p>
<p>Frequently turbo-fish notation is needed while calling this function:
<code>rdr.into_deserialize::&lt;RecordTyme&gt;();</code></p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>This shows how to deserialize CSV data into normal Rust structs. The
fields of the header row are used to match up the values in each row
to the fields of the struct.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;

<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::AsyncDeserializer;

<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    city: String,
    country: String,
    <span class="attr">#[serde(rename = <span class="string">"popcount"</span>)]
    </span>population: u64,
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,popcount
Boston,United States,4628910
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>iter = rdr.into_deserialize();

    <span class="kw">if let </span><span class="prelude-val">Some</span>(result) = iter.next().<span class="kw">await </span>{
        <span class="kw">let </span>record: Row = result<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(record, Row {
            city: <span class="string">"Boston"</span>.to_string(),
            country: <span class="string">"United States"</span>.to_string(),
            population: <span class="number">4628910</span>,
        });
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(From::from(<span class="string">"expected at least one record but got none"</span>))
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_deserialize_with_pos" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#538-543">source</a><h4 class="code-header">pub fn <a href="#method.into_deserialize_with_pos" class="fn">into_deserialize_with_pos</a>&lt;D&gt;(
    self,
) -&gt; <a class="struct" href="struct.DeserializeRecordsIntoStreamPos.html" title="struct csv_async::DeserializeRecordsIntoStreamPos">DeserializeRecordsIntoStreamPos</a>&lt;'r, R, D&gt;<div class="where">where
    D: <a class="trait" href="../serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a> + 'r,</div></h4></section></summary><div class="docblock"><p>Returns a owned stream over pairs of deserialized record and position
in reader stream before record read.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.headers" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#610-612">source</a><h4 class="code-header">pub async fn <a href="#method.headers" class="fn">headers</a>(&amp;mut self) -&gt; <a class="type" href="type.Result.html" title="type csv_async::Result">Result</a>&lt;&amp;<a class="struct" href="struct.StringRecord.html" title="struct csv_async::StringRecord">StringRecord</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a reference to the first row read by this parser.</p>
<p>If no row has been read yet, then this will force parsing of the first
row.</p>
<p>If there was a problem parsing the row or if it wasn’t valid UTF-8,
then this returns an error.</p>
<p>If the underlying reader emits EOF before any data, then this returns
an empty record.</p>
<p>Note that this method may be used regardless of whether <code>has_headers</code>
was enabled (but it is enabled by default).</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<p>This example shows how to get the header row of CSV data. Notice that
the header row does not appear as a record in the iterator!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::AsyncDeserializer;
 
<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    city: String,
    country: String,
    pop: u64,
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,pop
Boston,United States,4628910
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());

    <span class="comment">// We can read the headers before iterating.
    </span>{
    <span class="comment">// `headers` borrows from the reader, so we put this in its
    // own scope. That way, the borrow ends before we try iterating
    // below. Alternatively, we could clone the headers.
    </span><span class="kw">let </span>headers = rdr.headers().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(headers, <span class="macro">vec!</span>[<span class="string">"city"</span>, <span class="string">"country"</span>, <span class="string">"pop"</span>]);
    }

    {
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.deserialize::&lt;Row&gt;();
    <span class="macro">assert_eq!</span>(records.next().<span class="kw">await</span>.unwrap()<span class="question-mark">?</span>,
               Row {city: <span class="string">"Boston"</span>.to_string(),
                    country: <span class="string">"United States"</span>.to_string(),
                    pop: <span class="number">4628910 </span>});
    <span class="macro">assert!</span>(records.next().<span class="kw">await</span>.is_none());
    }

    <span class="comment">// We can also read the headers after iterating.
    </span><span class="kw">let </span>headers = rdr.headers().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(headers, <span class="macro">vec!</span>[<span class="string">"city"</span>, <span class="string">"country"</span>, <span class="string">"pop"</span>]);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_headers" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#679-681">source</a><h4 class="code-header">pub async fn <a href="#method.byte_headers" class="fn">byte_headers</a>(&amp;mut self) -&gt; <a class="type" href="type.Result.html" title="type csv_async::Result">Result</a>&lt;&amp;<a class="struct" href="struct.ByteRecord.html" title="struct csv_async::ByteRecord">ByteRecord</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a reference to the first row read by this parser as raw bytes.</p>
<p>If no row has been read yet, then this will force parsing of the first
row.</p>
<p>If there was a problem parsing the row then this returns an error.</p>
<p>If the underlying reader emits EOF before any data, then this returns
an empty record.</p>
<p>Note that this method may be used regardless of whether <code>has_headers</code>
was enabled (but it is enabled by default).</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<p>This example shows how to get the header row of CSV data. Notice that
the header row does not appear as a record in the iterator!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::AsyncDeserializer;

<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    city: String,
    country: String,
    <span class="attr">#[serde(rename = <span class="string">"pop"</span>)]
    </span>population: u64,
}
 
<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="macro">indoc::indoc!</span> {<span class="string">"
        city,country,pop
        Boston,United States,4628910
    "</span>};
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());

    <span class="comment">// We can read the headers before iterating.
    </span>{
    <span class="comment">// `headers` borrows from the reader, so we put this in its
    // own scope. That way, the borrow ends before we try iterating
    // below. Alternatively, we could clone the headers.
    </span><span class="kw">let </span>headers = rdr.byte_headers().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(headers, <span class="macro">vec!</span>[<span class="string">"city"</span>, <span class="string">"country"</span>, <span class="string">"pop"</span>]);
    }

    {
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.deserialize::&lt;Row&gt;();
    <span class="macro">assert_eq!</span>(records.next().<span class="kw">await</span>.unwrap()<span class="question-mark">?</span>,
               Row {city: <span class="string">"Boston"</span>.to_string(),
                    country: <span class="string">"United States"</span>.to_string(),
                    population: <span class="number">4628910 </span>});
    <span class="macro">assert!</span>(records.next().<span class="kw">await</span>.is_none());
    }

    <span class="comment">// We can also read the headers after iterating.
    </span><span class="kw">let </span>headers = rdr.byte_headers().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(headers, <span class="macro">vec!</span>[<span class="string">"city"</span>, <span class="string">"country"</span>, <span class="string">"pop"</span>]);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_headers" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#711-713">source</a><h4 class="code-header">pub fn <a href="#method.set_headers" class="fn">set_headers</a>(&amp;mut self, headers: <a class="struct" href="struct.StringRecord.html" title="struct csv_async::StringRecord">StringRecord</a>)</h4></section></summary><div class="docblock"><p>Set the headers of this CSV parser manually.</p>
<p>This overrides any other setting (including <code>set_byte_headers</code>). Any
automatic detection of headers is disabled. This may be called at any
time.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>csv_async::{AsyncDeserializer, StringRecord};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,pop
Boston,United States,4628910
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());

    <span class="macro">assert_eq!</span>(rdr.headers().<span class="kw">await</span><span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">"city"</span>, <span class="string">"country"</span>, <span class="string">"pop"</span>]);
    rdr.set_headers(StringRecord::from(<span class="macro">vec!</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]));
    <span class="macro">assert_eq!</span>(rdr.headers().<span class="kw">await</span><span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_byte_headers" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#743-745">source</a><h4 class="code-header">pub fn <a href="#method.set_byte_headers" class="fn">set_byte_headers</a>(&amp;mut self, headers: <a class="struct" href="struct.ByteRecord.html" title="struct csv_async::ByteRecord">ByteRecord</a>)</h4></section></summary><div class="docblock"><p>Set the headers of this CSV parser manually as raw bytes.</p>
<p>This overrides any other setting (including <code>set_headers</code>). Any
automatic detection of headers is disabled. This may be called at any
time.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>csv_async::{AsyncDeserializer, ByteRecord};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,pop
Boston,United States,4628910
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());

    <span class="macro">assert_eq!</span>(rdr.byte_headers().<span class="kw">await</span><span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">"city"</span>, <span class="string">"country"</span>, <span class="string">"pop"</span>]);
    rdr.set_byte_headers(ByteRecord::from(<span class="macro">vec!</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]));
    <span class="macro">assert_eq!</span>(rdr.byte_headers().<span class="kw">await</span><span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_record" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#785-787">source</a><h4 class="code-header">pub async fn <a href="#method.read_record" class="fn">read_record</a>(&amp;mut self, record: &amp;mut <a class="struct" href="struct.StringRecord.html" title="struct csv_async::StringRecord">StringRecord</a>) -&gt; <a class="type" href="type.Result.html" title="type csv_async::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Read a single row into the given record. Returns false when no more
records could be read.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this will never read the first record.</p>
<p>This method is useful when you want to read records as fast as
as possible. It’s less ergonomic than an iterator, but it permits the
caller to reuse the <code>StringRecord</code> allocation, which usually results
in higher throughput.</p>
<p>Records read via this method are guaranteed to have a position set
on them, even if the reader is at EOF or if an error is returned.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>csv_async::{AsyncDeserializer, StringRecord};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,pop
Boston,United States,4628910
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>record = StringRecord::new();

    <span class="kw">if </span>rdr.read_record(<span class="kw-2">&amp;mut </span>record).<span class="kw">await</span><span class="question-mark">? </span>{
        <span class="macro">assert_eq!</span>(record, <span class="macro">vec!</span>[<span class="string">"Boston"</span>, <span class="string">"United States"</span>, <span class="string">"4628910"</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(From::from(<span class="string">"expected at least one record but got none"</span>))
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_byte_record" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#827-829">source</a><h4 class="code-header">pub async fn <a href="#method.read_byte_record" class="fn">read_byte_record</a>(
    &amp;mut self,
    record: &amp;mut <a class="struct" href="struct.ByteRecord.html" title="struct csv_async::ByteRecord">ByteRecord</a>,
) -&gt; <a class="type" href="type.Result.html" title="type csv_async::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Read a single row into the given byte record. Returns false when no
more records could be read.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this will never read the first record.</p>
<p>This method is useful when you want to read records as fast as
as possible. It’s less ergonomic than an iterator, but it permits the
caller to reuse the <code>ByteRecord</code> allocation, which usually results
in higher throughput.</p>
<p>Records read via this method are guaranteed to have a position set
on them, even if the reader is at EOF or if an error is returned.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>csv_async::{ByteRecord, AsyncDeserializer};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,pop
Boston,United States,4628910
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>record = ByteRecord::new();

    <span class="kw">if </span>rdr.read_byte_record(<span class="kw-2">&amp;mut </span>record).<span class="kw">await</span><span class="question-mark">? </span>{
        <span class="macro">assert_eq!</span>(record, <span class="macro">vec!</span>[<span class="string">"Boston"</span>, <span class="string">"United States"</span>, <span class="string">"4628910"</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(From::from(<span class="string">"expected at least one record but got none"</span>))
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.position" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#886-888">source</a><h4 class="code-header">pub fn <a href="#method.position" class="fn">position</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.Position.html" title="struct csv_async::Position">Position</a></h4></section></summary><div class="docblock"><p>Return the current position of this CSV deserializer.</p>
<p>Because of borrowing rules this function can only be used when there is no
alive deserializer (which borrows mutable reader).
To know position during deserialization, <code>deserialize_with_pos</code> should be
used as shown in below example.</p>
<p>The byte offset in the position returned can be used to <code>seek</code> this
deserializer. In particular, seeking to a position returned here on the same
data will result in parsing the same subsequent record.</p>
<h5 id="example-reading-the-position"><a class="doc-anchor" href="#example-reading-the-position">§</a>Example: reading the position</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::io;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::{AsyncDeserializer, Position};

<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    city: String,
    country: String,
    popcount: u64,
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(io::Cursor::new(data));
    <span class="kw">let </span><span class="kw-2">mut </span>iter = rdr.deserialize_with_pos::&lt;Row&gt;();
    <span class="kw">let </span><span class="kw-2">mut </span>pos_at_boston = Position::new();
    <span class="kw">while let </span><span class="prelude-val">Some</span>((rec, pos)) = iter.next().<span class="kw">await </span>{
        <span class="kw">if </span>rec<span class="question-mark">?</span>.city == <span class="string">"Boston" </span>{
            pos_at_boston = pos;
        }
    }
    drop(iter); <span class="comment">// releases rdr borrow by iter
    </span><span class="kw">let </span>pos_at_end = rdr.position();
 
    <span class="macro">assert_eq!</span>(pos_at_boston.byte(),  <span class="number">22</span>);
    <span class="macro">assert_eq!</span>(pos_at_boston.line(),   <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(pos_at_boston.record(), <span class="number">1</span>);
    <span class="macro">assert_eq!</span>(pos_at_end.byte(),  <span class="number">79</span>);
    <span class="macro">assert_eq!</span>(pos_at_end.line(),   <span class="number">4</span>);
    <span class="macro">assert_eq!</span>(pos_at_end.record(), <span class="number">3</span>);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_done" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#931-933">source</a><h4 class="code-header">pub fn <a href="#method.is_done" class="fn">is_done</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this reader has been exhausted.</p>
<p>When this returns true, no more records can be read from this reader
(unless it has been seek to another position).</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::io;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::{AsyncDeserializer, Position};

<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    city: String,
    country: String,
    popcount: u64,
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(io::Cursor::new(data));
    <span class="macro">assert!</span>(!rdr.is_done());
    {
        <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.deserialize::&lt;Row&gt;();
        <span class="kw">while let </span><span class="prelude-val">Some</span>(record) = records.next().<span class="kw">await </span>{
            <span class="kw">let _ </span>= record<span class="question-mark">?</span>;
        }
    }
    <span class="macro">assert!</span>(rdr.is_done());
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_headers" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#938-940">source</a><h4 class="code-header">pub fn <a href="#method.has_headers" class="fn">has_headers</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this reader has been configured to
interpret the first record as a header record.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_ref" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#944-946">source</a><h4 class="code-header">pub fn <a href="#method.get_ref" class="fn">get_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;R</a></h4></section></summary><div class="docblock"><p>Returns a reference to the underlying reader.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#950-952">source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut R</a></h4></section></summary><div class="docblock"><p>Returns a mutable reference to the underlying reader.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_inner" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#959-961">source</a><h4 class="code-header">pub fn <a href="#method.into_inner" class="fn">into_inner</a>(self) -&gt; R</h4></section></summary><div class="docblock"><p>Unwraps this CSV reader, returning the underlying reader.</p>
<p>Note that any leftover data inside this reader’s internal buffer is
lost.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsyncDeserializer%3CR%3E-1" class="impl"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#964-1060">source</a><a href="#impl-AsyncDeserializer%3CR%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;R: <a class="trait" href="../futures_io/if_std/trait.AsyncRead.html" title="trait futures_io::if_std::AsyncRead">AsyncRead</a> + <a class="trait" href="../futures_io/if_std/trait.AsyncSeek.html" title="trait futures_io::if_std::AsyncSeek">AsyncSeek</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>&gt; <a class="struct" href="struct.AsyncDeserializer.html" title="struct csv_async::AsyncDeserializer">AsyncDeserializer</a>&lt;R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.seek" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#1035-1037">source</a><h4 class="code-header">pub async fn <a href="#method.seek" class="fn">seek</a>(&amp;mut self, pos: <a class="struct" href="struct.Position.html" title="struct csv_async::Position">Position</a>) -&gt; <a class="type" href="type.Result.html" title="type csv_async::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Seeks the underlying reader to the position given.</p>
<p>This comes with a few caveats:</p>
<ul>
<li>Any internal buffer associated with this reader is cleared.</li>
<li>If the given position does not correspond to a position immediately
before the start of a record, then the behavior of this reader is
unspecified.</li>
<li>Any special logic that skips the first record in the CSV reader
when reading or iterating over records is disabled.</li>
</ul>
<p>If the given position has a byte offset equivalent to the current
position, then no seeking is performed.</p>
<p>If the header row has not already been read, then this will attempt
to read the header row before seeking. Therefore, it is possible that
this returns an error associated with reading CSV data.</p>
<p>Note that seeking is performed based only on the byte offset in the
given position. Namely, the record or line numbers in the position may
be incorrect, but this will cause any future position generated by
this CSV reader to be similarly incorrect.</p>
<h5 id="example-seek-to-parse-a-record-twice"><a class="doc-anchor" href="#example-seek-to-parse-a-record-twice">§</a>Example: seek to parse a record twice</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::io;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>serde::Deserialize;
<span class="kw">use </span>csv_async::{AsyncDeserializer, Position};

<span class="attr">#[derive(Debug, Deserialize, Eq, PartialEq)]
</span><span class="kw">struct </span>Row {
    city: String,
    country: String,
    popcount: u64,
}

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">"\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncDeserializer::from_reader(io::Cursor::new(data));
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.deserialize_with_pos::&lt;Row&gt;();
    <span class="kw">let </span><span class="kw-2">mut </span>pos_at_boston = Position::new();
    <span class="kw">while let </span><span class="prelude-val">Some</span>((rec, pos)) = records.next().<span class="kw">await </span>{
        <span class="kw">if </span>rec<span class="question-mark">?</span>.city == <span class="string">"Boston" </span>{
            pos_at_boston = pos;
            <span class="comment">// no break here - we are reading data to end
        </span>}
    }
    drop(records); <span class="comment">// releases rdr borrowed by records

    // Now seek the reader back to `pos_at_boston`. This will let us read the
    // Boston's record again.
    </span>rdr.seek(pos_at_boston).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.into_deserialize::&lt;Row&gt;();
    <span class="kw">if let </span><span class="prelude-val">Some</span>(rec) = records.next().<span class="kw">await </span>{
        <span class="macro">assert_eq!</span>(rec<span class="question-mark">?</span>.city, <span class="string">"Boston"</span>);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(From::from(<span class="string">"After seek we should be before last record, but was at end of stream"</span>))
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.seek_raw" class="method"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#1053-1059">source</a><h4 class="code-header">pub async fn <a href="#method.seek_raw" class="fn">seek_raw</a>(
    &amp;mut self,
    seek_from: <a class="enum" href="https://doc.rust-lang.org/nightly/std/io/enum.SeekFrom.html" title="enum std::io::SeekFrom">SeekFrom</a>,
    pos: <a class="struct" href="struct.Position.html" title="struct csv_async::Position">Position</a>,
) -&gt; <a class="type" href="type.Result.html" title="type csv_async::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>This is like <code>seek</code>, but provides direct control over how the seeking
operation is performed via <code>io::SeekFrom</code>.</p>
<p>The <code>pos</code> position given <em>should</em> correspond the position indicated
by <code>seek_from</code>, but there is no requirement. If the <code>pos</code> position
given is incorrect, then the position information returned by this
reader will be similarly incorrect.</p>
<p>If the header row has not already been read, then this will attempt
to read the header row before seeking. Therefore, it is possible that
this returns an error associated with reading CSV data.</p>
<p>Unlike <code>seek</code>, this will always cause an actual seek to be performed.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-AsyncDeserializer%3CR%3E" class="impl"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#139">source</a><a href="#impl-Debug-for-AsyncDeserializer%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.AsyncDeserializer.html" title="struct csv_async::AsyncDeserializer">AsyncDeserializer</a>&lt;R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/csv_async/async_readers/ades_futures.rs.html#139">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-AsyncDeserializer%3CR%3E" class="impl"><a href="#impl-Freeze-for-AsyncDeserializer%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.AsyncDeserializer.html" title="struct csv_async::AsyncDeserializer">AsyncDeserializer</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-AsyncDeserializer%3CR%3E" class="impl"><a href="#impl-RefUnwindSafe-for-AsyncDeserializer%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.AsyncDeserializer.html" title="struct csv_async::AsyncDeserializer">AsyncDeserializer</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-AsyncDeserializer%3CR%3E" class="impl"><a href="#impl-Send-for-AsyncDeserializer%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.AsyncDeserializer.html" title="struct csv_async::AsyncDeserializer">AsyncDeserializer</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-AsyncDeserializer%3CR%3E" class="impl"><a href="#impl-Sync-for-AsyncDeserializer%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.AsyncDeserializer.html" title="struct csv_async::AsyncDeserializer">AsyncDeserializer</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-AsyncDeserializer%3CR%3E" class="impl"><a href="#impl-Unpin-for-AsyncDeserializer%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.AsyncDeserializer.html" title="struct csv_async::AsyncDeserializer">AsyncDeserializer</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-AsyncDeserializer%3CR%3E" class="impl"><a href="#impl-UnwindSafe-for-AsyncDeserializer%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.AsyncDeserializer.html" title="struct csv_async::AsyncDeserializer">AsyncDeserializer</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>