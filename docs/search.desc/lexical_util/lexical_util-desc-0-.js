searchState.loadedDescShard("lexical_util", 0, "Shared utilities for lexical conversion routines.\nSimple, shared algorithms for slices and iterators.\nUtilities for working with ASCII characters.\nDebugging assertions to check a radix is valid.\nPre-defined constants for numeric types.\nUtilities to process digits.\nOptimized division algorithms for u128.\nError type for numeric parsing functions.\nExtended precision floating-point type.\nPublic API for the number format packed struct.\nDefine FromLexical trait.\nDefine FromLexicalWithOptions trait.\nSpecialized iterator traits.\nFast multiplication routines.\nUtilities for Rust numbers.\nShared traits for the options API.\nResult type for numeric parsing functions.\nThe maximum digits that can be held in a u64 for a given …\nDefine ToLexical trait.\nDefine ToLexicalWithOptions trait.\nCopy bytes from source to destination.\nCount the number of leading characters equal to a given …\nCount the number of trailing characters equal to a given …\nTrim character from the end (right-side) of a slice.\nDetermine if a character is a valid ASCII character for …\nDetermine if a slice is all valid ASCII characters for …\nDetermine if a character is a valid ASCII letter.\nDetermine if a slice is all valid ASCII letters. Modified …\nAssertion the buffer has sufficient room for the output.\nCheck radix is equal to 10.\nDebug assertion the buffer has sufficient room for the …\nCheck radix is equal to 10.\nMaximum number of bytes required to serialize any number …\nMaximum number of bytes required to serialize a number to …\nMaximum number of bytes required to serialize a number to …\nThe size, in bytes, of formatted values.\nDetermine if a character is a digit.\nDetermine if a character is a digit with a radix known at …\nConvert a character to a digit.\nConvert a character to a digit with a radix known at …\nUnchecked, highly optimized algorithm to convert a char to …\nConvert a digit to a character. This uses a pre-computed …\nConvert a digit to a character with a radix known at …\nFast division/remainder algorithm for u128, without a fast …\nFast division/remainder algorithm for u128, without a fast …\nCalculate a div/remainder algorithm optimized for …\nOptimized fallback division/remainder algorithm for u128.\nCalculate the div/remainder of a value based on the radix.\nEmpty byte array found.\nEmpty exponent found.\nEmpty fraction found.\nEmpty integer found.\nEmpty mantissa found.\nError code during parsing, indicating failure type.\nExponent was present without fraction component.\nShort infinity string is too long.\nLong infinity string is too long.\nLong infinity string is too short: it must be as long as …\nInvalid character for a base prefix.\nInvalid character for a base suffix.\nInvalid consecutive exponent digit separator.\nInvalid consecutive fraction digit separator.\nInvalid consecutive integer digit separator.\nInvalid decimal point character.\nInvalid digit found before string termination.\nInvalid digit separator character.\nExponent was present but not allowed.\nInvalid base for the exponent.\nOptional exponent flags were set while disabling exponent …\nInvalid radix for the exponent digits.\nSet no positive exponent sign while requiring exponent …\nInvalid symbol to represent exponent notation.\nInvalid flags were set without the format feature.\nInvalid float parsing algorithm.\nInvalid precision flags for writing floats.\nInvalid short infinity string: must start with an <code>i</code> …\nInvalid long infinity string: must start with an <code>i</code> …\nInteger or integer component of float had invalid leading …\nInvalid radix for the mantissa (significant) digits.\nSet no positive mantissa sign while requiring mantissa …\nInvalid NaN string: must start with an <code>n</code> character.\nInvalid negative exponent break: break is above 0.\nInvalid negative sign for an unsigned type was found.\nInvalid positive exponent break: break is below 0.\nInvalid positive exponent sign was found.\nInvalid positive mantissa sign was found.\nInvalid positive sign for an integer was found.\nInvalid punctuation characters: multiple symbols overlap.\nInvalid radix for the significant digits.\nSet optional special float flags while disable special …\nNo exponent with required exponent notation.\nExponent sign was required(usize), but not found.\nMantissa sign was required(usize), but not found.\nIntegral sign was required(usize), but not found.\nNaN string is too long.\nIntegral overflow occurred during numeric parsing.\nAn error did not actually occur, and the result was …\nIntegral underflow occurred during numeric parsing.\nReturns the argument unchanged.\nGet the index for the parsing error.\nCalls <code>U::from(self)</code>.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nExtended precision floating-point type.\nBinary exponent for the extended-precision float.\nGet the exponent component.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMantissa for the extended-precision float.\nGet the mantissa component.\nMask to extract the base prefix character.\nShift to convert to and from a base prefix as a <code>u8</code>.\nMask to extract the base suffix character.\nShift to convert to and from a base suffix as a <code>u8</code>.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nBase prefixes are case-sensitive.\nBase suffixes are case-sensitive.\nExponent characters are case-sensitive.\nSpecial (non-finite) values are case-sensitive.\nNumber format for a Clojure literal floating-point number.\nNumber format to parse a Clojure float from string.\nNumber format for a Cobol literal floating-point number.\nNumber format to parse a Cobol float from string.\nNumber format for a Coffeescript literal floating-point …\nNumber format to parse a Coffeescript float from string.\nMultiple consecutive digit separators are allowed.\nNumber format for a C#1 literal floating-point number.\nNumber format to parse a C#1 float from string.\nNumber format for a C#2 literal floating-point number.\nNumber format to parse a C#2 float from string.\nNumber format for a C#3 literal floating-point number.\nNumber format to parse a C#3 float from string.\nNumber format for a C#4 literal floating-point number.\nNumber format to parse a C#4 float from string.\nNumber format for a C#5 literal floating-point number.\nNumber format to parse a C#5 float from string.\nNumber format for a C#6 literal floating-point number.\nNumber format to parse a C#6 float from string.\nNumber format for a C#7 literal floating-point number.\nNumber format to parse a C#7 float from string.\nNumber format for a C# literal floating-point number.\nNumber format to parse a C# float from string.\nNumber format for a C++03 literal floating-point number.\nNumber format for a C++03 string floating-point number.\nNumber format for a C++11 literal floating-point number.\nNumber format for a C++11 string floating-point number.\nNumber format for a C++14 literal floating-point number.\nNumber format for a C++14 string floating-point number.\nNumber format for a C++17 literal floating-point number.\nNumber format for a C++17 string floating-point number.\nNumber format for a C++20 literal floating-point number.\nNumber format for a C++20 string floating-point number.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nNumber format for a C++ literal floating-point number.\nNumber format to parse a C++ float from string.\nNumber format for a C literal floating-point number.\nNumber format to parse a C float from string.\nMask to extract the digit separator character.\nShift to convert to and from a digit separator as a <code>u8</code>.\nNumber format for a D literal floating-point number.\nNumber format to parse a D float from string.\nNumber format for an Elixir literal floating-point number.\nNumber format to parse an Elixir float from string.\nNumber format for an Elm literal floating-point number.\nNumber format to parse an Elm float from string.\nNumber format for an Erlang literal floating-point number.\nNumber format to parse an Erlang float from string.\nMask to extract the exponent base: the base the exponent …\nShift to convert to and from an exponent base as a <code>u32</code>.\nMultiple consecutive exponent digit separators are allowed.\nDigit separators are allowed between exponent digits.\nA digit separator is allowed before any exponent digits.\nMask to extract the exponent radix: the radix for the …\nShift to convert to and from an exponent radix as a <code>u32</code>.\nA digit separator is allowed after any exponent digits.\nNumber format for a FORTRAN literal floating-point number.\nNumber format to parse a FORTRAN float from string.\nMultiple consecutive fraction digit separators are allowed.\nDigit separators are allowed between fraction digits.\nA digit separator is allowed before any fraction digits.\nA digit separator is allowed after any fraction digits.\nNumber format for a F# literal floating-point number.\nNumber format to parse a F# float from string.\nNumber format for a Gambit-C literal floating-point number.\nNumber format to parse a Gambit-C float from string.\nNumber format for a Golang literal floating-point number.\nNumber format to parse a Golang float from string.\nNumber format for a Guile literal floating-point number.\nNumber format to parse a Guile float from string.\nNumber format for a Haskell literal floating-point number.\nNumber format to parse a Haskell float from string.\nMultiple consecutive integer digit separators are allowed.\nDigit separators are allowed between integer digits.\nA digit separator is allowed before any integer digits.\nA digit separator is allowed after any integer digits.\nDigit separators are allowed between digits.\nNumber format for a Javascript literal floating-point …\nNumber format to parse a Javascript float from string.\nNumber format for a Java literal floating-point number.\nNumber format to parse a Java float from string.\nNumber format for a JSON literal floating-point number.\nNumber format for a Julia literal floating-point number.\nNumber format to parse a Julia float from string.\nNumber format for a Kawa literal floating-point number.\nNumber format to parse a Kawa float from string.\nNumber format for a Kotlin literal floating-point number.\nNumber format to parse a Kotlin float from string.\nA digit separator is allowed before any digits.\nMask to extract the mantissa radix: the radix for the …\nShift to convert to and from a mantissa radix as a <code>u32</code>.\nNumber format for an Matlab literal floating-point number.\nNumber format to parse an Matlab float from string.\nNumber format for a MongoDB literal floating-point number.\nNumber format for a MySQL literal floating-point number.\nExponent notation is not allowed.\nExponent without a fraction component is not allowed.\nLeading zeros before a float value are not allowed.\nLeading zeros before an integer value are not allowed.\nPositive sign before the exponent is not allowed.\nPositive sign before the mantissa is not allowed.\nSpecial (non-finite) values are not allowed.\nNo value.\nBuild number format from specifications.\nNumber format for an Objective-C literal floating-point …\nNumber format to parse an Objective-C float from string.\nNumber format for an OCaml literal floating-point number.\nNumber format to parse an OCaml float from string.\nNumber format for an Octave literal floating-point number.\nNumber format to parse an Octave float from string.\nType with the exact same size as a <code>u8</code>.\nNumber format for a Perl literal floating-point number.\nNumber format to parse a Perl float from string.\nNumber format for a PHP literal floating-point number.\nNumber format to parse a PHP float from string.\nNumber format for a PostgreSQL literal floating-point …\nNumber format for a Python2 literal floating-point number.\nNumber format to parse a Python2 float from string.\nNumber format for a Python3.5 or lower literal …\nNumber format for a Python3.6 or higher literal …\nNumber format for a Python3 literal floating-point number.\nNumber format to parse a Python3 float from string.\nNumber format for a Python literal floating-point number.\nNumber format to parse a Python float from string.\nAlias for MANTISSA_RADIX.\nAlias for MANTISSA_RADIX_SHIFT.\nNumber format for a ReasonML literal floating-point number.\nNumber format to parse a ReasonML float from string.\nAt least 1 digit in the number is required.\nDigits are required after the exponent character. This …\nExponent notation is required.\nPositive sign before the exponent is required.\nDigits are required after the decimal point. This check …\nDigits are required before the decimal point.\nMantissa digits are required (either before or after the …\nPositive sign before the mantissa is required.\nNumber format for a Ruby literal floating-point number.\nNumber format to parse a Ruby float from string.\nNumber format for a Rust literal floating-point number.\nNumber format to parse a Rust float from string.\nNumber format for a R literal floating-point number.\nNumber format to parse a R float from string.\nNumber format for a Sage literal floating-point number.\nNumber format to parse a Sage float from string.\nNumber format for a Scala literal floating-point number.\nNumber format to parse a Scala float from string.\nAny digit separators are allowed in special (non-finite) …\nNumber format for a SQLite literal floating-point number.\nStandard number format. This is identical to the Rust …\nNumber format for a Swift literal floating-point number.\nNumber format to parse a Swift float from string.\nSome value of type <code>T</code>.\nNumber format for a TOML literal floating-point number.\nA digit separator is allowed after any digits.\nNumber format for a Visual Basic literal floating-point …\nNumber format to parse a Visual Basic float from string.\nNumber format for a XML literal floating-point number.\nNumber format for a YAML literal floating-point number.\nNumber format for a Zig literal floating-point number.\nNumber format to parse a Zig float from string.\nExtract the base prefix character from the format packed …\nExtract the base suffix character from the format packed …\nCreate 128-bit, packed number format struct from builder …\nSet if exponent characters are case-sensitive.\nSet if special (non-finite) values are case-sensitive.\nSet all consecutive digit separator flags.\nCreate number format for standard, decimal number.\nExtract the digit separator from the format packed struct.\nSet the digit separator for the number format.\nSet all digit separator flag masks.\nExtract the exponent base from the format packed struct. …\nSet if multiple consecutive exponent digit separators are …\nSet all exponent digit separator flag masks.\nSet if digit separators are allowed between exponent …\nSet if a digit separator is allowed before any exponent …\nExtract the exponent radix from the format packed struct. …\nSet if a digit separator is allowed after any exponent …\nGet the error type from the format packed struct.\nDetermine if the format packed struct is valid.\nSet if multiple consecutive fraction digit separators are …\nSet all fraction digit separator flag masks.\nSet if digit separators are allowed between fraction …\nSet if a digit separator is allowed before any fraction …\nSet if a digit separator is allowed after any fraction …\nReturns the argument unchanged.\nGet the optional character for the base prefix.\nGet the optional character for the base suffix.\nGet if base prefixes are case-sensitive.\nGet if base suffixes are case-sensitive.\nGet if exponent characters are case-sensitive.\nGet if special (non-finite) values are case-sensitive.\nGet the digit separator for the number format.\nGet the radix for the exponent.\nGet if multiple consecutive exponent digit separators are …\nGet if digit separators are allowed between exponent …\nGet if a digit separator is allowed before any exponent …\nGet the radix for exponent digits.\nGet if a digit separator is allowed after any exponent …\nGet if multiple consecutive fraction digit separators are …\nGet if digit separators are allowed between fraction …\nGet if a digit separator is allowed before any fraction …\nGet if a digit separator is allowed after any fraction …\nGet if multiple consecutive integer digit separators are …\nGet if digit separators are allowed between integer digits.\nGet if a digit separator is allowed before any integer …\nGet if a digit separator is allowed after any integer …\nGet the radix for mantissa digits.\nGet if exponent notation is not allowed.\nGet if an exponent without fraction is not allowed.\nGet if leading zeros before a float are not allowed.\nGet if leading zeros before an integer are not allowed.\nGet if a positive sign before the exponent is not allowed.\nGet if a positive sign before the mantissa is not allowed.\nGet if special (non-finite) values are not allowed.\nGet if digits are required after the exponent character.\nGet if exponent notation is required.\nGet if a sign symbol before the exponent is required.\nGet if digits are required after the decimal point.\nGet if digits are required before the decimal point.\nGet if at least 1 significant digit is required.\nGet if a sign symbol before the mantissa is required.\nGet if any digit separators are allowed in special …\nSet if multiple consecutive integer digit separators are …\nSet all integer digit separator flag masks.\nSet if digit separators are allowed between integer digits.\nSet if a digit separator is allowed before any integer …\nSet if a digit separator is allowed after any integer …\nSet all internal digit separator flags.\nCalls <code>U::from(self)</code>.\nDetermine if the base prefix character is valid.\nDetermine if the base suffix character is valid.\nDetermine if the digit separator is valid. Digit …\nDetermine if the provided exponent flags are valid.\nDetermine if all of the “punctuation” characters for …\nDetermine if all of the “punctuation” characters are …\nDetermine if the radix is valid.\nSet all leading digit separator flags.\nExtract the mantissa radix from the format packed struct.\nCreate new NumberFormatBuilder with default arguments.\nSet if exponent notation is not allowed.\nSet if an exponent without fraction is not allowed.\nSet if leading zeros before a float are not allowed.\nSet if leading zeros before an integer are not allowed.\nSet if a positive sign before the exponent is not allowed.\nSet if a positive sign before the mantissa is not allowed.\nSet if special (non-finite) values are not allowed.\nExtract a generic radix from the format and bitflags.\nRe-create builder from format.\nSet if digits are required for all float components.\nSet if digits are required after the exponent character.\nSet if exponent notation is required.\nSet if a sign symbol before the exponent is required.\nSet if digits are required after the decimal point.\nSet if digits are required before the decimal point.\nSet if at least 1 significant digit is required.\nSet if a sign symbol before the mantissa is required.\nSet if any digit separators are allowed in special …\nSet all trailing digit separator flags.\nTrait to simplify creation of a <code>Bytes</code> object.\nSlice iterator that skips characters matching a given …\nIterator over a contiguous block of bytes.\nDetermine if each yielded value is adjacent in memory.\nIf each yielded value is adjacent in memory.\nGet a ptr to the current start of the iterator.\nGet a ptr to the current start of the iterator.\nGet a slice to the current start of the iterator.\nGet a slice to the current start of the iterator.\nCreate <code>Bytes</code> from object.\nCheck if the next element is a given value without case …\nCheck if the next element is a given value without case …\nGet the current number of values returned by the iterator.\nGet the current number of values returned by the iterator.\nGet the current index of the iterator in the slice.\nGet the current index of the iterator in the slice.\nGet iterator over exponent digits.\nCheck if the next element is a given value.\nGet iterator over fraction digits.\nReturns the argument unchanged.\nGet iterator over integer digits.\nCalls <code>U::from(self)</code>.\nGet if the iterator cannot return any more elements.\nDetermine if the iterator is contiguous.\nGet if the buffer underlying the iterator is empty.\nGet if the buffer underlying the iterator is empty.\nGet the total number of elements in the underlying slice.\nGet the total number of elements in the underlying slice.\nCreate new byte object.\nPeek the next value of the iterator, without consuming it.\nCheck if the next element is a given value.\nPeek the next value of the iterator, without checking …\nTry to read a value of a different type from the iterator. …\nTry to read a value of a different type from the iterator. …\nRead a value of a difference type from the iterator. This …\nRead a value of a difference type from the iterator. This …\nSet the current index of the iterator in the slice.\nSet the current index of the iterator in the slice.\nSkip zeros from the start of the iterator\nGet iterator over special floating point values.\nAdvance the internal slice by <code>N</code> elements.\nAdvance the byte by <code>N</code> elements.\nAdvance the internal slice by 1 element.\nAdvance the byte by 1 element.\nMultiply two unsigned, integral values, and return the hi …\nMultiply two unsigned, integral values, and return the hi …\nAn interface for casting between machine scalars.\nType that can be converted to primitive with <code>as</code>.\nMask to determine if a full-carry occurred (1 in bit above …\nExponent portion of a denormal float.\nBias of the exponent.\nBitmask for the exponent, including the hidden bit.\nSize of the exponent.\nFloat information for native float types.\nBitmask for the hidden bit in exponent, which is an …\nPositive infinity as bits.\nIf the number is a signed type.\nDefines a trait that supports integral operations.\nBitmask for the mantissa (fraction), excluding the hidden …\nSize of the significand (mantissa) without hidden bit.\nMaximum exponent value in float.\nPositive infinity as bits.\nNumerical type trait.\nPrimitive type trait (which all have static lifetimes).\nBitmask for the sign bit.\nDefines a trait that supports signed integral operations.\nUnsigned type of the same size.\nDefines a trait that supports unsigned integral operations.\nAllows the high-level conversion of generic types as if <code>as</code> …\nCreates a number from another value that can be converted …\nGet the number of bits in a value.\nGet the fast ceiling of the quotient from integer division.\nGet the fast ceiling of the quotient from integer division.\nGet the fast ceiling modulus from integer division. Not …\nGet exponent component from the float.\nReturns true if the float is a denormal.\nReturns true if the least-significant bit is even.\nReturns true if the float’s least-significant mantissa …\nReturns true if the float is infinite.\nReturns true if the float is NaN.\nReturns true if the least-significant bit is odd.\nReturns true if the float’s least-significant mantissa …\nReturns true if the float is a NaN or Infinite.\nGet mantissa (significand) component from float.\nGet the max of two finite numbers.\nGet the min of two finite numbers.\nGet next greater float.\nGet next greater float for a positive float. Value must be …\nGet previous greater float, such that …\nGet previous greater float for a positive float. Value …\nRound a positive number to even.\nShared trait for all parser options.\nShared trait for all writer options.\nGet an upper bound on the buffer size.\nDetermine if the options are valid.\nDetermine if the options are valid.\nContains the error value\nContains the success value\nA specialized Result type for lexical operations.\nCalculate the maximum number of digits that can be …\nCalculate the maximum number of digits that can always be …\nCalculate the number of digits that can be processed …")