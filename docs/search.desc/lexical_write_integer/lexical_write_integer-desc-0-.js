searchState.loadedDescShard("lexical_write_integer", 0, "Fast lexical integer-to-string conversion routines.\nMaximum number of bytes required to serialize any number …\nMaximum number of bytes required to serialize a number to …\nMaximum number of bytes required to serialize a number to …\nThe size, in bytes, of formatted values.\nBuild number format from specifications.\nImmutable options to customize writing integers.\nCustom formatting options for writing a number.\nBuilder for <code>Options</code>.\nTrait for numerical types that can be serialized to bytes.\nTrait for numerical types that can be serialized to bytes …\nShared trait for all writer options.\nGet an upper bound on the buffer size.\nCreate 128-bit, packed number format struct from builder …\nSet if exponent characters are case-sensitive.\nSet if special (non-finite) values are case-sensitive.\nSet all consecutive digit separator flags.\nCreate number format for standard, decimal number.\nSet the digit separator for the number format.\nSet all digit separator flag masks.\nSet if multiple consecutive exponent digit separators are …\nSet all exponent digit separator flag masks.\nSet if digit separators are allowed between exponent …\nSet if a digit separator is allowed before any exponent …\nSet if a digit separator is allowed after any exponent …\nPublic API for the number format packed struct.\nSet if multiple consecutive fraction digit separators are …\nSet all fraction digit separator flag masks.\nSet if digit separators are allowed between fraction …\nSet if a digit separator is allowed before any fraction …\nSet if a digit separator is allowed after any fraction …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the optional character for the base prefix.\nGet the optional character for the base suffix.\nGet if base prefixes are case-sensitive.\nGet if base suffixes are case-sensitive.\nGet if exponent characters are case-sensitive.\nGet if special (non-finite) values are case-sensitive.\nGet the digit separator for the number format.\nGet the radix for the exponent.\nGet if multiple consecutive exponent digit separators are …\nGet if digit separators are allowed between exponent …\nGet if a digit separator is allowed before any exponent …\nGet the radix for exponent digits.\nGet if a digit separator is allowed after any exponent …\nGet if multiple consecutive fraction digit separators are …\nGet if digit separators are allowed between fraction …\nGet if a digit separator is allowed before any fraction …\nGet if a digit separator is allowed after any fraction …\nGet if multiple consecutive integer digit separators are …\nGet if digit separators are allowed between integer digits.\nGet if a digit separator is allowed before any integer …\nGet if a digit separator is allowed after any integer …\nGet the radix for mantissa digits.\nGet if exponent notation is not allowed.\nGet if an exponent without fraction is not allowed.\nGet if leading zeros before a float are not allowed.\nGet if leading zeros before an integer are not allowed.\nGet if a positive sign before the exponent is not allowed.\nGet if a positive sign before the mantissa is not allowed.\nGet if special (non-finite) values are not allowed.\nGet if digits are required after the exponent character.\nGet if exponent notation is required.\nGet if a sign symbol before the exponent is required.\nGet if digits are required after the decimal point.\nGet if digits are required before the decimal point.\nGet if at least 1 significant digit is required.\nGet if a sign symbol before the mantissa is required.\nGet if any digit separators are allowed in special …\nSet if multiple consecutive integer digit separators are …\nSet all integer digit separator flag masks.\nSet if digit separators are allowed between integer digits.\nSet if a digit separator is allowed before any integer …\nSet if a digit separator is allowed after any integer …\nSet all internal digit separator flags.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermine if the options are valid.\nSet all leading digit separator flags.\nCreate new NumberFormatBuilder with default arguments.\nSet if exponent notation is not allowed.\nSet if an exponent without fraction is not allowed.\nSet if leading zeros before a float are not allowed.\nSet if leading zeros before an integer are not allowed.\nSet if a positive sign before the exponent is not allowed.\nSet if a positive sign before the mantissa is not allowed.\nSet if special (non-finite) values are not allowed.\nConfiguration options for writing integers.\nRe-create builder from format.\nSet if digits are required for all float components.\nSet if digits are required after the exponent character.\nSet if exponent notation is required.\nSet if a sign symbol before the exponent is required.\nSet if digits are required after the decimal point.\nSet if digits are required before the decimal point.\nSet if at least 1 significant digit is required.\nSet if a sign symbol before the mantissa is required.\nSet if any digit separators are allowed in special …\nSerializer for a number-to-string conversion.\nSerializer for a number-to-string conversion.\nSerializer for a number-to-string conversion.\nSerializer for a number-to-string conversion.\nSet all trailing digit separator flags.\nMask to extract the base prefix character.\nShift to convert to and from a base prefix as a <code>u8</code>.\nMask to extract the base suffix character.\nShift to convert to and from a base suffix as a <code>u8</code>.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nBase prefixes are case-sensitive.\nBase suffixes are case-sensitive.\nExponent characters are case-sensitive.\nSpecial (non-finite) values are case-sensitive.\nNumber format for a Clojure literal floating-point number.\nNumber format to parse a Clojure float from string.\nNumber format for a Cobol literal floating-point number.\nNumber format to parse a Cobol float from string.\nNumber format for a Coffeescript literal floating-point …\nNumber format to parse a Coffeescript float from string.\nMultiple consecutive digit separators are allowed.\nNumber format for a C#1 literal floating-point number.\nNumber format to parse a C#1 float from string.\nNumber format for a C#2 literal floating-point number.\nNumber format to parse a C#2 float from string.\nNumber format for a C#3 literal floating-point number.\nNumber format to parse a C#3 float from string.\nNumber format for a C#4 literal floating-point number.\nNumber format to parse a C#4 float from string.\nNumber format for a C#5 literal floating-point number.\nNumber format to parse a C#5 float from string.\nNumber format for a C#6 literal floating-point number.\nNumber format to parse a C#6 float from string.\nNumber format for a C#7 literal floating-point number.\nNumber format to parse a C#7 float from string.\nNumber format for a C# literal floating-point number.\nNumber format to parse a C# float from string.\nNumber format for a C++03 literal floating-point number.\nNumber format for a C++03 string floating-point number.\nNumber format for a C++11 literal floating-point number.\nNumber format for a C++11 string floating-point number.\nNumber format for a C++14 literal floating-point number.\nNumber format for a C++14 string floating-point number.\nNumber format for a C++17 literal floating-point number.\nNumber format for a C++17 string floating-point number.\nNumber format for a C++20 literal floating-point number.\nNumber format for a C++20 string floating-point number.\nNumber format for a C++98 literal floating-point number.\nNumber format for a C++98 string floating-point number.\nNumber format for a C++ literal floating-point number.\nNumber format to parse a C++ float from string.\nNumber format for a C literal floating-point number.\nNumber format to parse a C float from string.\nMask to extract the digit separator character.\nShift to convert to and from a digit separator as a <code>u8</code>.\nNumber format for a D literal floating-point number.\nNumber format to parse a D float from string.\nNumber format for an Elixir literal floating-point number.\nNumber format to parse an Elixir float from string.\nNumber format for an Elm literal floating-point number.\nNumber format to parse an Elm float from string.\nNumber format for an Erlang literal floating-point number.\nNumber format to parse an Erlang float from string.\nMask to extract the exponent base: the base the exponent …\nShift to convert to and from an exponent base as a <code>u32</code>.\nMultiple consecutive exponent digit separators are allowed.\nDigit separators are allowed between exponent digits.\nA digit separator is allowed before any exponent digits.\nMask to extract the exponent radix: the radix for the …\nShift to convert to and from an exponent radix as a <code>u32</code>.\nA digit separator is allowed after any exponent digits.\nNumber format for a FORTRAN literal floating-point number.\nNumber format to parse a FORTRAN float from string.\nMultiple consecutive fraction digit separators are allowed.\nDigit separators are allowed between fraction digits.\nA digit separator is allowed before any fraction digits.\nA digit separator is allowed after any fraction digits.\nNumber format for a F# literal floating-point number.\nNumber format to parse a F# float from string.\nNumber format for a Gambit-C literal floating-point number.\nNumber format to parse a Gambit-C float from string.\nNumber format for a Golang literal floating-point number.\nNumber format to parse a Golang float from string.\nNumber format for a Guile literal floating-point number.\nNumber format to parse a Guile float from string.\nNumber format for a Haskell literal floating-point number.\nNumber format to parse a Haskell float from string.\nMultiple consecutive integer digit separators are allowed.\nDigit separators are allowed between integer digits.\nA digit separator is allowed before any integer digits.\nA digit separator is allowed after any integer digits.\nDigit separators are allowed between digits.\nNumber format for a Javascript literal floating-point …\nNumber format to parse a Javascript float from string.\nNumber format for a Java literal floating-point number.\nNumber format to parse a Java float from string.\nNumber format for a JSON literal floating-point number.\nNumber format for a Julia literal floating-point number.\nNumber format to parse a Julia float from string.\nNumber format for a Kawa literal floating-point number.\nNumber format to parse a Kawa float from string.\nNumber format for a Kotlin literal floating-point number.\nNumber format to parse a Kotlin float from string.\nA digit separator is allowed before any digits.\nMask to extract the mantissa radix: the radix for the …\nShift to convert to and from a mantissa radix as a <code>u32</code>.\nNumber format for an Matlab literal floating-point number.\nNumber format to parse an Matlab float from string.\nNumber format for a MongoDB literal floating-point number.\nNumber format for a MySQL literal floating-point number.\nExponent notation is not allowed.\nExponent without a fraction component is not allowed.\nLeading zeros before a float value are not allowed.\nLeading zeros before an integer value are not allowed.\nPositive sign before the exponent is not allowed.\nPositive sign before the mantissa is not allowed.\nSpecial (non-finite) values are not allowed.\nNo value.\nBuild number format from specifications.\nNumber format for an Objective-C literal floating-point …\nNumber format to parse an Objective-C float from string.\nNumber format for an OCaml literal floating-point number.\nNumber format to parse an OCaml float from string.\nNumber format for an Octave literal floating-point number.\nNumber format to parse an Octave float from string.\nType with the exact same size as a <code>u8</code>.\nNumber format for a Perl literal floating-point number.\nNumber format to parse a Perl float from string.\nNumber format for a PHP literal floating-point number.\nNumber format to parse a PHP float from string.\nNumber format for a PostgreSQL literal floating-point …\nNumber format for a Python2 literal floating-point number.\nNumber format to parse a Python2 float from string.\nNumber format for a Python3.5 or lower literal …\nNumber format for a Python3.6 or higher literal …\nNumber format for a Python3 literal floating-point number.\nNumber format to parse a Python3 float from string.\nNumber format for a Python literal floating-point number.\nNumber format to parse a Python float from string.\nAlias for MANTISSA_RADIX.\nAlias for MANTISSA_RADIX_SHIFT.\nNumber format for a ReasonML literal floating-point number.\nNumber format to parse a ReasonML float from string.\nAt least 1 digit in the number is required.\nDigits are required after the exponent character. This …\nExponent notation is required.\nPositive sign before the exponent is required.\nDigits are required after the decimal point. This check …\nDigits are required before the decimal point.\nMantissa digits are required (either before or after the …\nPositive sign before the mantissa is required.\nNumber format for a Ruby literal floating-point number.\nNumber format to parse a Ruby float from string.\nNumber format for a Rust literal floating-point number.\nNumber format to parse a Rust float from string.\nNumber format for a R literal floating-point number.\nNumber format to parse a R float from string.\nNumber format for a Sage literal floating-point number.\nNumber format to parse a Sage float from string.\nNumber format for a Scala literal floating-point number.\nNumber format to parse a Scala float from string.\nAny digit separators are allowed in special (non-finite) …\nNumber format for a SQLite literal floating-point number.\nStandard number format. This is identical to the Rust …\nNumber format for a Swift literal floating-point number.\nNumber format to parse a Swift float from string.\nSome value of type <code>T</code>.\nNumber format for a TOML literal floating-point number.\nA digit separator is allowed after any digits.\nNumber format for a Visual Basic literal floating-point …\nNumber format to parse a Visual Basic float from string.\nNumber format for a XML literal floating-point number.\nNumber format for a YAML literal floating-point number.\nNumber format for a Zig literal floating-point number.\nNumber format to parse a Zig float from string.\nExtract the base prefix character from the format packed …\nExtract the base suffix character from the format packed …\nExtract the digit separator from the format packed struct.\nExtract the exponent base from the format packed struct. …\nExtract the exponent radix from the format packed struct. …\nGet the error type from the format packed struct.\nDetermine if the format packed struct is valid.\nDetermine if the base prefix character is valid.\nDetermine if the base suffix character is valid.\nDetermine if the digit separator is valid. Digit …\nDetermine if the provided exponent flags are valid.\nDetermine if all of the “punctuation” characters for …\nDetermine if all of the “punctuation” characters are …\nDetermine if the radix is valid.\nExtract the mantissa radix from the format packed struct.\nExtract a generic radix from the format and bitflags.\nImmutable options to customize writing integers.\nBuilder for <code>Options</code>.\nStandard number format.\nBuild the Options struct.\nBuild the Options struct with bounds validation.\nGet OptionsBuilder as a static function.\nCheck if the builder state is valid.\nCheck if the options state is valid.\nCreate new options builder with default options.\nCreate options with default values.\nCreate OptionsBuilder using existing values.")