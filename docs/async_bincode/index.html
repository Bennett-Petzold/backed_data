<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Asynchronous access to a bincode-encoded item stream."><title>async_bincode - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="async_bincode" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (4074d4902 2024-08-23)" data-channel="nightly" data-search-js="search-a2a4ff0acfd716f8.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-cb0df477c2d67d00.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../async_bincode/index.html">async_<wbr>bincode</a><span class="version">0.7.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">async_bincode</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/async_bincode/lib.rs.html#1-169">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Asynchronous access to a bincode-encoded item stream.</p>
<p>This crate enables you to asynchronously read from a bincode-encoded stream, or write
bincoded-encoded values. <code>bincode</code> does not support this natively, as it cannot easily <a href="https://github.com/TyOverby/bincode/issues/229">resume
from stream errors while encoding or decoding</a>.</p>
<p><code>async-bincode</code> works around that on the receive side by buffering received bytes until a full
element’s worth of data has been received, and only then calling into bincode. To make this
work, it relies on the sender to prefix each encoded element with its encoded size.</p>
<p>On the write side, <code>async-bincode</code> buffers the serialized values, and asynchronously sends the
resulting bytestream.</p>
<p>This crate provides two sets of types in two separate modules. The types in the <code>futures</code>
module work with the <code>futures_io</code>/<code>async-std</code> ecosystem. The types in the <code>tokio</code> module work
with the <code>tokio</code> ecosystem.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.BincodeWriterFor"><code>pub use crate::writer::BincodeWriterFor;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="futures/index.html" title="mod async_bincode::futures">futures</a></div><div class="desc docblock-short">Asynchronous access to a bincode-encoded item stream using <code>futures_io</code>. See the top-level
documentation and the documentation for <a href="futures/struct.AsyncBincodeReader.html" title="struct async_bincode::futures::AsyncBincodeReader"><code>AsyncBincodeReader</code></a>, <a href="futures/struct.AsyncBincodeWriter.html" title="struct async_bincode::futures::AsyncBincodeWriter"><code>AsyncBincodeWriter</code></a>, and
<a href="futures/struct.AsyncBincodeStream.html" title="struct async_bincode::futures::AsyncBincodeStream"><code>AsyncBincodeStream</code></a>.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AsyncDestination.html" title="struct async_bincode::AsyncDestination">Async<wbr>Destination</a></div><div class="desc docblock-short">A marker that indicates that the wrapping type is compatible with <code>AsyncBincodeReader</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.SyncDestination.html" title="struct async_bincode::SyncDestination">Sync<wbr>Destination</a></div><div class="desc docblock-short">A marker that indicates that the wrapping type is compatible with stock <code>bincode</code> receivers.</div></li></ul></section></div></main></body></html>