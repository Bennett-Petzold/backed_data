<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Unsafe code information."><title>backed_data::extra_docs::unsafe_usage - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-b25d77b18a16a9a4.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="backed_data" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (6de928dce 2024-08-18)" data-channel="nightly" data-search-js="search-ef54e092fea9c776.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-cb0df477c2d67d00.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../backed_data/index.html">backed_<wbr>data</a><span class="version">0.3.0</span></h2></div><h2 class="location"><a href="#">Module unsafe_<wbr>usage</a></h2><div class="sidebar-elems"><h2><a href="../index.html">In backed_<wbr>data::<wbr>extra_<wbr>docs</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">backed_data</a>::<wbr><a href="../index.html">extra_docs</a>::<wbr><a class="mod" href="#">unsafe_usage</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/backed_data/extra_docs/unsafe_usage.rs.html#7-74">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Unsafe code information.</p>
<p>Some features need capabilities only unlocked by <code>unsafe</code> code.
Unsafe code is tested by Miri where possible. It cannot execute all valid
Rust code, so some tests need to be left uncovered. Please open an issue or
PR for any unsound use of <code>unsafe</code>. The isolation of unsafe code to only
the explicitly unsafe features is guarded by a conditional
<code>forbid(unsafe_code)</code> in the crate root.</p>
<h2 id="safe-features"><a class="doc-anchor" href="#safe-features">§</a>Safe Features</h2>
<ul>
<li><code>array</code></li>
<li><code>directory</code></li>
<li><code>async</code></li>
<li><code>bincode</code></li>
<li><code>serde_json</code></li>
<li><code>simd_json</code></li>
<li><code>csv</code></li>
<li><code>async_bincode</code></li>
<li><code>async_csv</code></li>
<li><code>zstd</code></li>
<li><code>zstdmt</code></li>
<li><code>async_zstd</code></li>
<li><code>async_zstdmt</code></li>
<li><code>network</code></li>
</ul>
<h2 id="unsafe-features"><a class="doc-anchor" href="#unsafe-features">§</a>Unsafe Features</h2>
<p>See documentation and comments in the feature function/structs for
finer-grained justifications.</p>
<h4 id="unsafe_array"><a class="doc-anchor" href="#unsafe_array">§</a><code>unsafe_array</code></h4>
<p>The <code>generic</code> methods are premised on the guarantees of
<a href="../../../stable_deref_trait/trait.StableDeref.html" title="trait stable_deref_trait::StableDeref"><code>StableDeref</code></a>. Mainly, we can borrow
from the storage pointed to by a container even if the container itself is
moved on stack. <code>unsafe</code> is needed to keep the container handles alive as
long as their referenced data is considered valid, but also allow the
handles to move.</p>
<p>The mutable iterators also need <code>unsafe</code>. The nature of a one-way iterator
is that the accesses to each element in the container are unique, but this
borrowing is outside of the slice API. So unsafe pointers are needed to
give out the exclusive mutable element access.</p>
<p>The complex iterators that save storage or flush on drop also <code>unsafe</code>, so
that the last instance of the handle can perform mutable cleanup. The
shared mutable element is not modified besides creation and cleanup.</p>
<h4 id="tokio--smol"><a class="doc-anchor" href="#tokio--smol">§</a><code>tokio</code> &amp; <code>smol</code></h4>
<p>Due to <a href="https://doc.rust-lang.org/nightly/core/mem/fn.forget.html" title="fn core::mem::forget"><code>std::mem::forget</code></a>, scoped async blocks are inherently unsafe. The
runtime execution options provided for runtime executors rely on scoped
async blocks, so need to expose an <code>unsafe</code> function for them.</p>
<h4 id="mmap"><a class="doc-anchor" href="#mmap">§</a><code>mmap</code></h4>
<p>All mmap APIs are unsafe, due to the possibility of an external process
modifying the file. <code>unsafe</code> is also used for mutable mmaps, so that it can
be preserved after the write handle is dropped but enforce mutability rules
at runtime. Otherwise the mmap would be pointlessly read again from disk
when the write handle is dropped and read handles are opened.</p>
<h4 id="encrypted"><a class="doc-anchor" href="#encrypted">§</a><code>encrypted</code></h4>
<p><a href="../../../secrets/traits/bytes/trait.Bytes.html" title="trait secrets::traits::bytes::Bytes"><code>Bytes</code></a> needs an unsafe block to extend a blanket implementation.
<a href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send"><code>Send</code></a> and <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync"><code>Sync</code></a> standard library <em>lints</em> around pointers (not necessarily protecting from
unsafe behavior, just the potential of pointer hackery that breaks those rules) also need unsafe to bypass.</p>
<p>There is also a use of <a href="../../utils/struct.BorrowExtender.html" title="struct backed_data::utils::BorrowExtender"><code>BorrowExtender</code></a> that requires a bit of lifetime
hacking to match the valid lifetime of the borrow.</p>
</div></details></section></div></main></body></html>